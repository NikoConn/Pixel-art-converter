<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Art Converter Enhanced</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #f8f9fa; }
  #color-palette { margin-bottom: 10px; }
  canvas { border: 1px solid #ccc; margin: 10px; background: #fff; }
  .container { display: flex; flex-wrap: wrap; gap: 20px; }
</style>
</head>
<body>

<h1>Pixel Art Converter Enhanced</h1>

<label>Upload image: <input type="file" id="upload" accept="image/*"></label><br><br>
<label>Grid width (cells): <input type="number" id="gridWidth" value="16"></label><br>
<label>Grid height (cells): <input type="number" id="gridHeight" value="16"></label><br><br>

<div id="color-palette">
  <h3>Color palette:</h3>
  <div id="colors"></div>
  <button id="addColor">Add color</button>
</div>

<button id="process">Process Image</button>

<div class="container">
  <div>
    <h3>Original</h3>
    <canvas id="originalCanvas"></canvas>
  </div>
  <div>
    <h3>Pixelated with Grid</h3>
    <canvas id="pixelCanvas"></canvas>
  </div>
</div>

<script>
const upload = document.getElementById('upload');
const gridWidthInput = document.getElementById('gridWidth');
const gridHeightInput = document.getElementById('gridHeight');
const addColorBtn = document.getElementById('addColor');
const colorsDiv = document.getElementById('colors');
const processBtn = document.getElementById('process');
const originalCanvas = document.getElementById('originalCanvas');
const pixelCanvas = document.getElementById('pixelCanvas');
const ctxOriginal = originalCanvas.getContext('2d');
const ctxPixel = pixelCanvas.getContext('2d');
let image = null;

// Bloques y pesos HSL ajustables
const blockW = 20, blockH = 20;
const Hweight = 3, Sweight = 1.5, Lweight = 1;

addColorInput();
addColorBtn.addEventListener('click', addColorInput);

function addColorInput() {
  const input = document.createElement('input');
  input.type = 'color';
  input.value = '#ff0000';
  colorsDiv.appendChild(input);
}

upload.addEventListener('change', e => {
  const file = e.target.files[0];
  if(!file) return;
  const img = new Image();
  img.onload = () => {
    image = img;
    originalCanvas.width = img.width;
    originalCanvas.height = img.height;
    ctxOriginal.drawImage(img,0,0);
  };
  img.src = URL.createObjectURL(file);
});

// =====================
// RGB → HSL
// =====================
function rgb2hsl([r,g,b]){
  r/=255; g/=255; b/=255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let h=0, s=0, l=(max+min)/2;
  if(max!==min){
    const d = max-min;
    s = l>0.5? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d +2; break;
      case b: h=(r-g)/d +4; break;
    }
    h/=6;
  }
  return [h,s,l];
}

// =====================
// Color promedio de región
// =====================
function averageColor(imgData, xStart, yStart, cellW, cellH, width){
  let rSum=0,gSum=0,bSum=0, count=0;
  for(let y=0;y<cellH;y++){
    for(let x=0;x<cellW;x++){
      const px = xStart + x;
      const py = yStart + y;
      if(px>=width) continue;
      const i = (py*width + px)*4;
      rSum += imgData[i];
      gSum += imgData[i+1];
      bSum += imgData[i+2];
      count++;
    }
  }
  return [rSum/count, gSum/count, bSum/count].map(v=>Math.round(v));
}

// =====================
// Closest color HSL ponderado
// =====================
function closestColorHSLWeighted(pixelRGB, paletteRGB){
  const pHSL = rgb2hsl(pixelRGB);
  let minDist = Infinity, closest = paletteRGB[0];
  for(const c of paletteRGB){
    const cHSL = rgb2hsl(c);
    const dist = Math.sqrt(
      Math.pow((pHSL[0]-cHSL[0])*Hweight,2) +
      Math.pow((pHSL[1]-cHSL[1])*Sweight,2) +
      Math.pow((pHSL[2]-cHSL[2])*Lweight,2)
    );
    if(dist<minDist){ minDist=dist; closest=c; }
  }
  return closest;
}

// =====================
// Procesar imagen
// =====================
processBtn.addEventListener('click', () => {
  if(!image) return alert('Upload an image first.');
  const gridW = parseInt(gridWidthInput.value);
  const gridH = parseInt(gridHeightInput.value);
  const paletteRGB = Array.from(colorsDiv.querySelectorAll('input')).map(c=>hexToRgb(c.value));

  // Canvas temporal para resize
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = gridW;
  tempCanvas.height = gridH;
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.drawImage(image,0,0,gridW,gridH);
  const imgData = tempCtx.getImageData(0,0,gridW,gridH).data;

  const offsetLeft = 30, offsetTop = 30;
  pixelCanvas.width = offsetLeft + gridW*blockW;
  pixelCanvas.height = offsetTop + gridH*blockH;
  ctxPixel.fillStyle = '#fff';
  ctxPixel.fillRect(0,0,pixelCanvas.width,pixelCanvas.height);

  // Procesar cada celda
  const origCanvas = document.createElement('canvas');
  origCanvas.width = image.width; origCanvas.height = image.height;
  const origCtx = origCanvas.getContext('2d');
  origCtx.drawImage(image,0,0);
  const origData = origCtx.getImageData(0,0,image.width,image.height).data;
  const cellWorig = Math.floor(image.width/gridW);
  const cellHorig = Math.floor(image.height/gridH);

  for(let y=0;y<gridH;y++){
    for(let x=0;x<gridW;x++){
      const avg = averageColor(origData,x*cellWorig,y*cellHorig,cellWorig,cellHorig,image.width);
      const closest = closestColorHSLWeighted(avg,paletteRGB);
      ctxPixel.fillStyle = `rgb(${closest[0]},${closest[1]},${closest[2]})`;
      ctxPixel.fillRect(offsetLeft + x*blockW, offsetTop + y*blockH, blockW, blockH);
    }
  }

  // Dibujar grid
  ctxPixel.strokeStyle = '#999';
  ctxPixel.lineWidth = 0.5;
  for(let x=0;x<=gridW;x++){
    const xPos = offsetLeft + x*blockW;
    ctxPixel.beginPath();
    ctxPixel.moveTo(xPos, offsetTop);
    ctxPixel.lineTo(xPos, offsetTop + gridH*blockH);
    ctxPixel.stroke();
  }
  for(let y=0;y<=gridH;y++){
    const yPos = offsetTop + y*blockH;
    ctxPixel.beginPath();
    ctxPixel.moveTo(offsetLeft, yPos);
    ctxPixel.lineTo(offsetLeft + gridW*blockW, yPos);
    ctxPixel.stroke();
  }

  // Dibujar ejes
  ctxPixel.fillStyle = '#000';
  ctxPixel.font = '12px sans-serif';
  ctxPixel.textAlign = 'center';
  ctxPixel.textBaseline = 'middle';
  for(let x=0;x<gridW;x++){
    ctxPixel.fillText(x, offsetLeft + x*blockW + blockW/2, offsetTop/2);
  }
  ctxPixel.textAlign = 'right';
  for(let y=0;y<gridH;y++){
    ctxPixel.fillText(y, offsetLeft-5, offsetTop + y*blockH + blockH/2);
  }
});

// =====================
// Helper: hex → RGB
// =====================
function hexToRgb(hex){
  const bigint = parseInt(hex.slice(1),16);
  return [(bigint>>16)&255,(bigint>>8)&255, bigint&255];
}

</script>
</body>
</html>
